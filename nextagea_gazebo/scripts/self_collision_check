#!/usr/bin/env python
# Self-collision checker for Nextage platform

import pyexotica as exo
from pyexotica.publish_trajectory import *
import signal
import sys
import warnings
import rospy
from time import sleep
import numpy as np
from pyexotica.tools import check_whether_trajectory_is_collision_free_by_subsampling, get_colliding_links
from trajectory_msgs.msg import JointTrajectoryPoint, JointTrajectory
from sensor_msgs.msg import JointState
from control_msgs.msg import JointTrajectoryControllerState

class colours:
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'

class SelfCollisionCheck:
    '''Self-collision checker for the Nextage platform. Node sits in front of trajectory controllers and filters
    out potentially harmful trajectories that may cause self-collisions'''

    def __init__(self, MODE, CONTROLLER_TYPE):
        # Initial setup and sub/pub to nodes
        self.controller_type = CONTROLLER_TYPE
        self.input_traj = rospy.Subscriber(rospy.resolve_name("~traj_input"), JointTrajectory, self.input_callback, queue_size=1)
        self.output_traj = rospy.Publisher(rospy.resolve_name("~traj_output"), JointTrajectory, queue_size=1)
        self.arm_info = rospy.Subscriber(rospy.resolve_name("~arm_input"), JointTrajectoryControllerState, self.arm_callback, queue_size=1)

        # Get EXOTica problem, different controllers correspond to different problem setups with different JointGroup
        if self.controller_type == "botharm":
            self.problem = exo.Setup.load_problem('{nextagea_gazebo}/config/botharms_collision_setup.xml')
        elif self.controller_type == "rarm":
            self.problem = exo.Setup.load_problem('{nextagea_gazebo}/config/rarm_collision_setup.xml')
        elif self.controller_type == "larm":
            self.problem = exo.Setup.load_problem('{nextagea_gazebo}/config/larm_collision_setup.xml')
        else:
            raise ValueError("Unrecognised trajectory input: %s" % self.controller_type)
        
        self.mode = MODE
        self.check_trajectory = False
        self.rate = rospy.Rate(10)

    def input_callback(self, data):
        self.check_trajectory = True
        self.trajectory_message = data
    
    def arm_callback(self, data):
        # Get current joint states
        self.arm_state = data

    def spin(self):
        while not rospy.is_shutdown():
            if self.check_trajectory:
                # TODO: Wrap in try/except block
                # TODO: Currently outputs a self-collision if it starts in self-collision and then moves out of it, is this desired behaviour?

                # Find robot's current state
                current_arms = list(self.arm_state.actual.positions)
                print(current_arms)

                # Strip JointTrajectory down to be in EXOTica solution form
                list_traj = [current_arms]
                for i in range(0, len(self.trajectory_message.points)):
                    list_traj.append(list(self.trajectory_message.points[i].positions))
                exotica_traj = np.array([np.array(x) for x in list_traj])

                traj_check = check_whether_trajectory_is_collision_free_by_subsampling(self.problem.get_scene(), exotica_traj)

                if traj_check:
                    # Pass through trajectory
                    self.output_traj.publish(self.trajectory_message)
                else:
                    if self.mode == '-warn':
                        # Print warning, but also pass through trajectory
                        print(colours.WARNING + "[WARN] Self-collision detected on following links:")
                        get_colliding_links(self.problem.get_scene())
                        print(colours.ENDC)
                        self.output_traj.publish(self.trajectory_message)
                    elif self.mode == '-error':
                        # Print error, don't pass through trajectory
                        print(colours.FAIL + "[ERROR] Self-collision detected on following links:")
                        get_colliding_links(self.problem.get_scene())
                        print(colours.ENDC)                        
                
                self.check_trajectory = False

            self.rate.sleep()


def main(args):
    # Sets warning/error message behaviour & controller type
    MODE = args[1]
    CONTROLLER_TYPE = args[2]

    rospy.init_node('self_collision_check')
    col = SelfCollisionCheck(MODE, CONTROLLER_TYPE)
    try:
        col.spin()
    except KeyboardInterrupt:
        print("Shutting down")

if __name__ == '__main__':
    main(sys.argv)